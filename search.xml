<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ICO容器-依赖注入</title>
    <url>/2020/05/27/Dependency/</url>
    <content><![CDATA[<hr>
<h1>IOC容器</h1>
<blockquote>
IOC是一种编程思想,不局限与任何一种语言,任何语言都可以实现这种思想，它的设计思想是想把创建对象，管理对象生命周期，程序集之间的解耦的工作交给第三方容器来处理。<br>
<a id="more"></a>
IOC作用:

<pre><code>1.注册类型,服务注册，将服务（类）以依赖注入的方式，添加到容器里,就是服务注册！
2.解析实例,比如我们注册了一个A类实例，这个时候我们不需要new了，直接从容器里面请求这个实例</code></pre></blockquote>
<h1>依赖注入</h1>
<blockquote>
我将会以讲故事的形式，给大家来介绍依赖注入和IOC容器。<br>
故事:假设我家的小宝出生了，这个时候饿了，肯定需要吃东西，对嘛，<br>

<pre><code>你会怎么办了？
1.叫外卖、去厨房找吃的、冰箱、冲牛奶  （主动）
2.叫妈妈、叫奶奶 （被动）</code></pre></blockquote>
<h3>解析:</h3>

<pre><code>这个时候饿了，肯定的情况下，需要食物对嘛？
1.方案1:我们主动获取食物，是有风险的。(比如并不知道哪些东西能吃的,不符合常理)(主动获取,我们称谓正转)
2.方案2:被动获取，食物是抽象的，父母给你的，决定安全，且适合你的(被动获取的,我们称谓反转,反转是食物的控制权)</code></pre><h3>说明:</h3>

<pre><code>食物是小宝所依赖的,也是抽象的,把所依赖的对象，反转了，就是控制反转(IOC)。
食物妈妈做好以后给你，或者喂给你，这个时候就是注入了。
妈妈就扮演者IOC容器的角色。</code></pre><p>没人在乎你怎样在深夜痛哭，也没人在乎你辗转反侧的要熬几个秋。外人只看结果，自己独撑过程。等我们都明白了这个道理，便不会再在人前矫情，四处诉说以求宽慰。晚安！</p>
]]></content>
      <categories>
        <category>ICO容器</category>
      </categories>
      <tags>
        <tag>ICO容器</tag>
      </tags>
  </entry>
  <entry>
    <title>24种设计模式</title>
    <url>/2020/07/14/DesignPatterns/</url>
    <content><![CDATA[<hr>
<blockquote>
设计模式:我们程序开发中针对特定问题的解决方案总结。(前辈的经验总结,可以随着总结的经验的增多,我们完全可以总结出属于自己专利的设计模式),接下来我们会以三个方面讲述，准备开撸吧。<br>
</blockquote>
<a id="more"></a>
<span id="inline-blue">1.创建型设计模式 </span>
<h1>单例模式</h1>
<blockquote>
 【1】概念:单例模式就是使用中，始终只有一个对象的实例。基本方法就是提供一个静态的访问点(方法)保证只有一个实例，而不会重复创建。<br>
 【2】在特定情况下，节省对象的创建资源，避免性能损失。<br>
 【3】高性能的非关系型数据库redis、memcache、mongoDB,底层都需要一个连接池，都会用到。
</blockquote>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用单例模式(单线程)</span><br><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        TestClass testClass &#x3D; TestClass.GetInstance();</span><br><span class="line">        testClass.TestMethod();</span><br><span class="line"></span><br><span class="line">        TestClass testClass1 &#x3D; TestClass.GetInstance();</span><br><span class="line">        testClass1.TestMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class TestClass</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;[1]创建一个私有的静态成员变量,用来保存当前的实例</span><br><span class="line">    private static TestClass Instance;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; [2]私有化构造方法:避免外界直接new这个类的实例</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    private TestClass()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(DateTime.Now.ToLongTimeString() + &quot;TestClass构造方法开始执行时间&quot;);</span><br><span class="line">        System.Threading.Thread.Sleep(2000);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; [3]创建一个让外界能够获取到的实例方法</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    public static TestClass GetInstance()</span><br><span class="line">    &#123;</span><br><span class="line">        if (Instance &#x3D;&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            Instance &#x3D; new TestClass();</span><br><span class="line">        &#125;</span><br><span class="line">        return Instance;</span><br><span class="line">    &#125;</span><br><span class="line">    public void TestMethod()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(DateTime.Now.ToLongTimeString() + &quot;TestMethod方法执行时间&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用单例模式(多线程方案解决一 加锁)</span><br><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Task.Factory.StartNew(() &#x3D;&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            TestClass testClass &#x3D; TestClass.GetInstance();</span><br><span class="line">            testClass.TestMethod();</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        Task.Factory.StartNew(() &#x3D;&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            TestClass testClass1 &#x3D; TestClass.GetInstance();</span><br><span class="line">            testClass1.TestMethod();</span><br><span class="line">        &#125;);</span><br><span class="line">        Console.Read();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class TestClass</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;[1]创建一个私有的静态成员变量,用来保存当前的实例</span><br><span class="line">    private static TestClass Instance;</span><br><span class="line">    &#x2F;&#x2F;[2]私有化构造方法:避免外界直接new这个类的实例</span><br><span class="line">    private TestClass()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(DateTime.Now.ToLongTimeString() + &quot;TestClass构造方法开始执行时间&quot;);</span><br><span class="line">        System.Threading.Thread.Sleep(2000);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;[3]创建一个让外界能够获取到的实例方法</span><br><span class="line">    &#x2F;&#x2F;[4]创建一个静态只读的辅助对象(就是lock使用)</span><br><span class="line">    private static readonly object heiperObject &#x3D; new object();</span><br><span class="line">    public static TestClass GetInstance()</span><br><span class="line">    &#123;</span><br><span class="line">        if (Instance &#x3D;&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            lock (heiperObject)</span><br><span class="line">            &#123;</span><br><span class="line">                if (Instance &#x3D;&#x3D; null)</span><br><span class="line">                &#123;</span><br><span class="line">                    Instance &#x3D; new TestClass();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return Instance;</span><br><span class="line">    &#125;</span><br><span class="line">    public void TestMethod()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(DateTime.Now.ToLongTimeString() + &quot;TestMethod方法执行时间&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用单例模式(多线程方案解决二 初始实例化)</span><br><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Task.Factory.StartNew(() &#x3D;&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            TestClass testClass &#x3D; TestClass.GetInstance();</span><br><span class="line">            testClass.TestMethod();</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        Task.Factory.StartNew(() &#x3D;&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            TestClass testClass1 &#x3D; TestClass.GetInstance();</span><br><span class="line">            testClass1.TestMethod();</span><br><span class="line">        &#125;);</span><br><span class="line">        Console.Read();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class TestClass</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;[1]创建一个私有的静态成员变量,用来保存当前的实例,在第一次引用成员变量的时候就创建了。</span><br><span class="line">    &#x2F;&#x2F;其实我们就是把这个对象的创建交给CLR,这种方式本身就是线程安全。</span><br><span class="line">    private static TestClass Instance&#x3D;new TestClass();</span><br><span class="line">    &#x2F;&#x2F;[2]私有化构造方法:避免外界直接new这个类的实例</span><br><span class="line">    private TestClass()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(DateTime.Now.ToLongTimeString() + &quot;TestClass构造方法开始执行时间&quot;);</span><br><span class="line">        System.Threading.Thread.Sleep(2000);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;[3]创建一个让外界能够获取到的实例方法</span><br><span class="line">    public static TestClass GetInstance()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(DateTime.Now.ToLongTimeString() + &quot;GetInstance方法执行时间&quot;);</span><br><span class="line">        return Instance;</span><br><span class="line">    &#125;</span><br><span class="line">    public void TestMethod()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(DateTime.Now.ToLongTimeString() + &quot;TestMethod方法执行时间&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><span id="inline-purple">2.结构型设计模式 </span><br><span id="inline-yellow">3.行为型设计模式 </span></p>
]]></content>
      <categories>
        <category>24种设计模式</category>
      </categories>
      <tags>
        <tag>24种设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>OOA、OOD、OOP设计思想</title>
    <url>/2020/07/13/OOADPesign/</url>
    <content><![CDATA[<hr>
<h1>OOA面向对象分析</h1>
<blockquote>
OOA设计思想:面向对象分析<br>
   【1】首先要明确你要做什么？<br>
   【2】做成什么样子？也就是基本的需要分析，明确你要实现的功能。<br>
   【3】当前市场同行软件有什么参考？比如我们这个，参考的是酷我音乐播放器(UI设计、核心功能的取舍)<br>
   【4】细化自己的需求(进一步的对需求进行可行性分析)<br>
   【5】准备开始设计项目<br>
</blockquote>
<a id="more"></a>
<h1>OOD面向对象设计</h1>
<blockquote>
OOD设计思想:面向对象设计(UML设计)<br>
   【1】明确项目类型？一般数据库应用系统？（模式单一）or 工具应用型系统<br>
   【2】工具型应用软件有哪些特点:<br>
            1.分析类<br>
            2.设计类<br>
            3.组合类<br>
</blockquote>
<h1>OOP面向对象编程</h1>
<blockquote>
OOP设计思想:面向对象的编程/实现<br>
【1】对象定义规格的求精过程
     对于OOA所抽象出来的对象&类以及汇集的分析文档，OOD需要有一个根据设计要求整理和求精的过程，是指更能符合oop的需要。这个整理和求精过程主要有两个方面；一是根据面向对象的概念模型整理分析所确定的对象结构、属性、方法等内容，改正错误的内容，删去不必要和重复的内容等。而是进行分类整理，以便于下一步数据库设计和程序处理模块设计的必要。整理的方法主要是进行归类，对类、对象、属性、方法和结构、主题进行归类。<br>
【2】数据模型和数据库设计数据模型的设计需要确定类与对象属性的内容,消息连接的方式.系统访问.数据模型的方法等.最后每个对象实例的数据都必须落实到面向对象的库结构模型中.<br>
【3】优化:<br>
    OOD的优化设计过程是从另一个角度对分析结果和处理业务过程的整理归纳,优化包括对象和结构的优化,抽象,继承.
    对象和结构的模块化表示OOD提供了一种范式,这种范式支持对类和结构的模块化.这种模块符合一般模块化所要求的的所有特点,如信息隐蔽性好,内部聚合度强和模块之间耦合度弱等.
    集成化使得单个构建有机的结合在一起,相互支持.
</blockquote>]]></content>
      <categories>
        <category>OOA、OOD、OOP设计思想</category>
      </categories>
      <tags>
        <tag>OOA、OOD、OOP设计思想</tag>
      </tags>
  </entry>
  <entry>
    <title>对象之间六大关系</title>
    <url>/2020/07/13/ObjectRelation/</url>
    <content><![CDATA[<hr>
<blockquote>
对象之间的关系<br>
   【1】纵向: （树形）继承-->实现 (父类--子类)  接口--->实现<br>
   【2】横向:  (平行)  由弱到强的关系：依赖-->关联-->聚合-->组合-->继承(泛型)-->实现（关系链是我们研究的重点）
</blockquote>
<a id="more"></a>
<h1>依赖关系-Dependence</h1>
<blockquote>
关系特点:一个类中,"使用"到了另一个类，这种"使用"是临时的,较弱的关系<br>
典型应用:一个类作为另一个类中方法的参数,或者这个方法的局部变量<br>
</blockquote>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ClassA</span><br><span class="line">&#123;</span><br><span class="line">    public void Mothod1(ClassB cb) </span><br><span class="line">    &#123;</span><br><span class="line">        cb.Test();</span><br><span class="line">    &#125;</span><br><span class="line">    public void Mothod2()</span><br><span class="line">    &#123;</span><br><span class="line">        ClassB cb &#x3D; new ClassB();</span><br><span class="line">        cb.Test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ClassB</span><br><span class="line">&#123;</span><br><span class="line">    public void Test() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1>关联关系-Association</h1>
<blockquote>
举例:比如客户和订单之间就是一种关联关系。一个对象和另一个对象是有关联的,但是这种关系是客观的关系，而非组成关系。<br>
关系特点:一个类A中,"使用"到了另一个类B,这种"使用"是长期的,较强的关系。<br>
典型应用:一个类作为另一个类中"成员"。可以是一对一,一对多,(集合对象)<br>
组合形式:单向,双向,自关联<br>
</blockquote>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ClassA</span><br><span class="line">&#123;</span><br><span class="line">    public ClassB classB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ClassB</span><br><span class="line">&#123;</span><br><span class="line">    private List&lt;ClassA&gt; caList;</span><br><span class="line">    public void Test() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;自关联</span><br><span class="line">public class ClassC</span><br><span class="line">&#123;</span><br><span class="line">    private ClassC classC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1>聚合关系-Aggregation是关联关系的一种特例</h1>
<blockquote>
举例:汽车和发动机？轮胎？/ 电脑和键盘？鼠标....整体与局部的关系<br>
关系特点:也表示一个对象和另一个对象有关联,但是对象之间是整体和部分的关系！整体和部分可以分开。<br>
典型应用:一个对象作为另一个类的《成员》<br>
组合形式:通过构造方法或者普通方法为成员赋值,对象是从外面创建的,然后传递进来。<br>
</blockquote>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;电脑 整体</span><br><span class="line">public class ClassA</span><br><span class="line">&#123;</span><br><span class="line">    public ClassB _classB;</span><br><span class="line"></span><br><span class="line">    public ClassA()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ClassA(ClassB classB)</span><br><span class="line">    &#123;</span><br><span class="line">        this._classB &#x3D; classB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void SetKeyboard(ClassB classB)</span><br><span class="line">    &#123;</span><br><span class="line">        this._classB &#x3D; classB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;键盘&#x2F;鼠标 部分</span><br><span class="line">public class ClassB</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;敲打</span><br><span class="line">    public void Clike() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;使用</span><br><span class="line">public class TestClass </span><br><span class="line">&#123;</span><br><span class="line">    private  ClassA classA &#x3D; new ClassA();</span><br><span class="line"></span><br><span class="line">    private ClassA classA1 &#x3D; new ClassA(new ClassB());</span><br><span class="line">    public void Test() </span><br><span class="line">    &#123;</span><br><span class="line">        classA.SetKeyboard(new ClassB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1>组合关系-Compostion</h1>
<blockquote>
举例:我和我媳妇<br>
关系特点:也表示一个对象和另一个对象有关联,但是对象之间是整体和部分的关系！"只不过"整体和部分不可以分开。并且整体和部分共生死。<br>
典型应用:一个对象作为另一个类的《成员》<br>
组合形式:通过构造方法"内"或者普通方法"内"直接创建,对象是从内部创建的,不用传递,这点是区别与聚合。<br>
</blockquote>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;手</span><br><span class="line">public class Person</span><br><span class="line">&#123;</span><br><span class="line">    public Hand hand;</span><br><span class="line"></span><br><span class="line">    public Person()</span><br><span class="line">    &#123;</span><br><span class="line">        this.hand &#x3D; new Hand();&#x2F;&#x2F;代表人出生就有手啊。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;手</span><br><span class="line">public class Hand</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;扣腚</span><br><span class="line">    public void Coding() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1>总结</h1>
<blockquote>
   【1】依赖:可以使用你，偶然的，用完就丢。<br>
   【2】关联:需要使用你，长期的，甩不掉。<br>
   【3】聚合:团队的成员，大家关系比较紧密，但是并不是非你不可。<br>
   【4】组合:我们是一家，关系非常紧密，谁也不能缺少。<br>
</blockquote>

]]></content>
      <categories>
        <category>对象之间六大关系</category>
      </categories>
      <tags>
        <tag>对象之间六大关系</tag>
      </tags>
  </entry>
  <entry>
    <title>.NET Core 初识</title>
    <url>/2020/05/25/NetCore/</url>
    <content><![CDATA[<hr>
<blockquote>
.Net Core是一个开源的,是可以跨平台.跨架构.支持命令行.部署灵活.兼容性强的框架。<br>
.Net Cree开源的,源码放在Github上面,属于社区开源，不仅仅是微软，社区也会提供支持。<br>
.Net Core采用包化的管理方式，增加轻量性。<br>
</blockquote>
<a id="more"></a>
<h1>ASP.NET Core启动类</h1>
<blockquote>
现在我们来简单介绍一下.Net Core3.1启动程序的两个类!<br>
Program:被称谓主机配置和创建类!<br>
Startup:被称谓Asp.Net Core应用的启动类,接下来,我会详细的描述每一组代码的意义和用途.<br>
</blockquote>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;主机配置和创建类</span><br><span class="line">public class Program</span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;程序入口</span><br><span class="line">    public static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;CreateHostBuilder是配置主机</span><br><span class="line">        &#x2F;&#x2F;Build是创建主机 (.Net Core源码在这里执行了一组委托(创建主机))</span><br><span class="line">        &#x2F;&#x2F;Run运行主机</span><br><span class="line">        CreateHostBuilder(args).Build().Run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;这里为小白补充一下,什么是主机,用来干嘛的</span><br><span class="line">    &#x2F;&#x2F;(主机:负责应用的启动类和生存期管理,配置服务器和请求处理管道,默认设置日志记录,依赖关系的注入和&#x2F;&#x2F;&#x2F;配置,主机是一个封装了应用资源的对象,.Net Core里的一个类(Host))</span><br><span class="line">    &#x2F;&#x2F;配置主机(.Net Core有两种主机,泛型,通用的主机)</span><br><span class="line">    public static IHostBuilder CreateHostBuilder(string[] args) &#x3D;&gt;</span><br><span class="line">      &#x2F;&#x2F;Host 主机静态类里面有一个CreateDefaultBuilder方法,是一个默认的创建主机构建器!</span><br><span class="line">      &#x2F;&#x2F;ConfigureWebHostDefaults:Web主机(他是通用主机的扩展,他提供额外Web功能,支持Http,集成了&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;Kestrel,内置了IIS集成)</span><br><span class="line">      Host.CreateDefaultBuilder(args)</span><br><span class="line">          .ConfigureWebHostDefaults(webBuilder &#x3D;&gt;</span><br><span class="line">          &#123;</span><br><span class="line">              &#x2F;&#x2F;指定ASP.NET Core应用启动类(今天先写到这里,明天继续)</span><br><span class="line">              webBuilder.UseStartup&lt;Startup&gt;();</span><br><span class="line">          &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[加油,希望能为看的人,带来收获!]  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;ASP.NET Core Web应用的启动类</span><br><span class="line">public class Startup </span><br><span class="line">&#123;</span><br><span class="line">     &#x2F;&#x2F;什么时候执行配置服务,在程序执行完Build()之后,运行主机以前执行配置服务!</span><br><span class="line">     &#x2F;&#x2F;配置服务</span><br><span class="line">     &#x2F;&#x2F;ConfigureServices以依赖注入的方式将服务添加到服务(IOC)容器</span><br><span class="line">     public void ConfigureServices(IServiceCollection services)</span><br><span class="line">     &#123;</span><br><span class="line">          &#x2F;&#x2F;Asp.NET Core内置的服务组件</span><br><span class="line">          &#x2F;&#x2F;添加对控制器和APi相关功能的支持,但是不支持视图和页面(Web Api的模板使用)</span><br><span class="line">          services.AddControllers();</span><br><span class="line">          &#x2F;&#x2F;MVC的默认模板使用的</span><br><span class="line">          services.AddControllersWithViews();</span><br><span class="line">          &#x2F;&#x2F;Web应用程序(Razor)</span><br><span class="line">          services.AddRazorPages();</span><br><span class="line">          &#x2F;&#x2F;这个MVC他是3.0之前的版本,2.x版本使用的</span><br><span class="line">          services.AddMvc(); </span><br><span class="line">          </span><br><span class="line">          &#x2F;&#x2F;以上的都是内置的,也可以添加第三方的服务,方法一致,这里将不过多描述了.</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F;服务的生存周期</span><br><span class="line">          &#x2F;&#x2F;请求一个实例(是有生存周期,生存期)</span><br><span class="line">          &#x2F;&#x2F;三种:</span><br><span class="line">          &#x2F;&#x2F;  瞬死:A类控制器依赖B类服务,也给实例出来,如果B类是瞬死的,那梅一次都会生成一个新的实例</span><br><span class="line">          &#x2F;&#x2F;  作用域:每一次有客户请求时,的实例只会请求一次,在这次的请求中,后面的操作还需要这个B类实&#x2F;&#x2F;例,他不会在创建了,把之前的拿过来直接用.</span><br><span class="line">          &#x2F;&#x2F;  单例:整个应用的生命周期，只要是向服务容器请求示例，第一次才会创建，之后都是使用这个。</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F;注册服务的使用方式,可以采用构造函数注入的方式使用.</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;配置管道</span><br><span class="line">     public void Configure(IApplicationBuilder app, IWebHostEnvironment env)</span><br><span class="line">     &#123;</span><br><span class="line">          &#x2F;&#x2F;如果想知道怎么添加中间件的,什么是终端中间件,怎么自定义中间件,中间件的顺序是怎么样的</span><br><span class="line">          &#x2F;&#x2F;可以加群,有学习文档.或者问群主:群号:782237863</span><br><span class="line">          </span><br><span class="line">          &#x2F;&#x2F;判断是否是开发环境</span><br><span class="line">          if (env.IsDevelopment())</span><br><span class="line">          &#123;</span><br><span class="line">               &#x2F;&#x2F;开发人员异常页面中间件,如果有异常,他会吧异常页面显示出来,且界面友好.</span><br><span class="line">               app.UseDeveloperExceptionPage();</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F;终端路由中间件</span><br><span class="line">          &#x2F;&#x2F;识别路由，匹配路由和终结点</span><br><span class="line">          app.UseRouting();</span><br><span class="line">          &#x2F;&#x2F;终结点中间件,配置路由和终结点之间的映射关系的</span><br><span class="line">          &#x2F;&#x2F;终结点:可以视为应用程序提供针对HTTP请求的处理器</span><br><span class="line">          &#x2F;&#x2F;MVC应用，终结点就对应着控制器中的某个方法</span><br><span class="line">          app.UseEndpoints(endpoints &#x3D;&gt;</span><br><span class="line">          &#123;</span><br><span class="line">               &#x2F;&#x2F;配置</span><br><span class="line">               endpoints.MapGet(&quot;&#x2F;&quot;, async context &#x3D;&gt;</span><br><span class="line">               &#123;</span><br><span class="line">                  await context.Response.WriteAsync(&quot;Hello World!&quot;);</span><br><span class="line">               &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>人生要学会储蓄。你若耕耘，就储存了一次丰收；你若努力，就储存了一个希望；你若微笑，就储存了一份快乐。你能支取什么，取决于你储蓄了什么。没有储存友谊，就无法支取帮助；没有储存学识，就无法支取能力；没有储存汗水，就无法支取成长。想要取之不尽的幸福，要储蓄感恩和付出。晚安！</p>
]]></content>
      <categories>
        <category>.NET Core 初识</category>
      </categories>
      <tags>
        <tag>.NET Core 初识</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象六大原则</title>
    <url>/2020/07/13/SixPrinciples/</url>
    <content><![CDATA[<hr>
<blockquote>
面向对象的六大原则，就是让我们设计程序带入OOP思想，目标:让程序高扩展、高可维护、高性能。<br>
</blockquote>
<a id="more"></a>
<h1>单一职责(SRP)</h1>
<blockquote>
<!-- <span id="inline-blue"> 站点配置文件 </span>
<span id="inline-purple"> 主题配置文件 </span>
<span id="inline-yellow"> 站点配置文件 </span>
<span id="inline-green"> 主题配置文件 </span> -->
概念:一个类只负责一个功能领域中相关的职责实现。也就是不能设计万能类。<br>
PS:工具类型的软件需要涉及的类(UI、实体类、业务类)数控库应用系统(UI、实体类、业务类、数据
    访问类、工具类)<br>
UI:属于边界类：主要是用来收集用户操作数据，或者展示数据给用户，他不应该有具体的，
               或者更多业务参与，更不能有其他的任务。<br>
实例：三层架构设计理论基础，也是对象职责明确原则(单一职责)<br>
好处：各个类各负其责！好处，当一个类的修改变化，不会影响到整个的程序。<br>
</blockquote>

<h1>里氏替换原则(LSP)</h1>
<blockquote>
概念:子类必须能够替换掉它的父类类型，反之不行。<br>
PS:里氏替换原则是实现开闭原则的重要方式之一<br>
UI:提醒大家，以后变成尽量针对"基类"、"父类"、“编程”！换句话是，针对"接口"编程。<br>
实例：人，可以被男人、女人替换的。父类 变量=子类对象 
好处：子类可以替换父类，不仅原有的父类功能不受影响，而且还能扩展自己的新的行为。<br>
</blockquote>

<h1>迪米特法则(Lod)</h1>
<blockquote>
概念:也叫最小化原则。当两个类之间直接通信的时候，会导致"高度"依赖（高耦合）
          为了解决这个问题，我们应该尽量的避免这两个类直接“接触”(低耦合),可以通过一个第三者做转发。<br>
PS:A->B->C<br>
UI:迪米特法则根本思想就是让类之间解耦，实现是松耦合，达到更多的复用，一个类的修改不影响其他类。<br>
实例：用户--->公司客服系统--->售后服务 如果你去找销售员，就是直接耦合！
好处：封装思想，尽量降低成员的方权限，而不是全部public。一个类依赖的员一个类的实现越少越好！<br>
</blockquote>

<h1>开闭原则(OCP)</h1>
<blockquote>
概念: 封闭修改，开放扩展。当需求变化的时候，我们尽量扩展对象，而不是修改原有对象。<br>
</blockquote>

<h1>依赖倒置原则(DIP)</h1>
<blockquote>
概念: 抽象不应该依赖于细节，细节应该依赖于抽象。<br>
PS:抽象不应该依赖于细节理解:生产主板的时候，是不用考虑那个厂家的"模块"。
                 细节应该依赖于抽象的理解:生产各个模块的时候，必须遵循主板的接口！<br>
UI:面向抽象编程就是说的DIP<br>
实例：电脑主板，各个模块，都是按照主板接口来实现的，谁是抽象部分？主板各种插槽。
                    细节:内存条，硬盘，独立显卡
</blockquote>


<h1>接口隔离原则(ISP)</h1>
<blockquote>
概念: 一个对象和另一个对象交互，所依赖的内容减少到最小，也就是说一个接口类设计必须严格遵循"单一职责"。
                 不要设计万能接口，也不要设计过多接口，换句话说不能让接口泛滥。<br>
PS:拆分多少合适？依靠大家的经验<br>
实例：通过接口隔离，我们单独增加了接口类，方法也做了相应的扩展(实现自由组装，灵活方便)
                  (非常类似于:数据库中的二范式或三范式!)
</blockquote>

<h1>总结</h1>
<blockquote>
1.单一职责:对象职责单一化
2.开闭原则:对象修改最小化
3.里氏替换原则:程序扩展具体方法
4.迪米特法则:高内聚低耦合
5.依赖倒置原则:不应该依赖于细节，依赖于抽象。
6.接口隔离原则:接口设计要适中。
</blockquote>]]></content>
      <categories>
        <category>面向对象六大原则</category>
      </categories>
      <tags>
        <tag>面向对象六大原则</tag>
      </tags>
  </entry>
</search>
