<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>.NET Core</title>
    <url>/2020/05/25/NetCore/</url>
    <content><![CDATA[<hr>
<h1>初识.NET Core</h1>
<blockquote>
.Net Core是一个开源的,是可以跨平台.跨架构.支持命令行.部署灵活.兼容性强的框架。<br>
.Net Cree开源的,源码放在Github上面,属于社区开源，不仅仅是微软，社区也会提供支持。<br>
.Net Core采用包化的管理方式，增加轻量性。<br>
</blockquote>
<a id="more"></a>
<h1>ASP.NET Core启动类</h1>
<blockquote>
现在我们来简单介绍一下.Net Core3.1启动程序的两个类!<br>
Program:被称谓主机配置和创建类!<br>
Startup:被称谓Asp.Net Core应用的启动类,接下来,我会详细的描述每一组代码的意义和用途.<br>
</blockquote>

<pre><code>//主机配置和创建类
public class Program
{ 

    //程序入口
    public static void Main(string[] args)
    {
        //CreateHostBuilder是配置主机
        //Build是创建主机 (.Net Core源码在这里执行了一组委托(创建主机))
        //Run运行主机
        CreateHostBuilder(args).Build().Run();
    }

    //这里为小白补充一下,什么是主机,用来干嘛的
    //(主机:负责应用的启动类和生存期管理,配置服务器和请求处理管道,默认设置日志记录,依赖关系的注入和///配置,主机是一个封装了应用资源的对象,.Net Core里的一个类(Host))
    //配置主机(.Net Core有两种主机,泛型,通用的主机)
    public static IHostBuilder CreateHostBuilder(string[] args) =&gt;
      //Host 主机静态类里面有一个CreateDefaultBuilder方法,是一个默认的创建主机构建器!
      //ConfigureWebHostDefaults:Web主机(他是通用主机的扩展,他提供额外Web功能,支持Http,集成了//////Kestrel,内置了IIS集成)
      Host.CreateDefaultBuilder(args)
          .ConfigureWebHostDefaults(webBuilder =&gt;
          {
              //指定ASP.NET Core应用启动类(今天先写到这里,明天继续)
              webBuilder.UseStartup&lt;Startup&gt;();
          });
}</code></pre><p>[加油,希望能为看的人,带来收获!]</p>
<pre><code>//ASP.NET Core Web应用的启动类
public class Startup 
{
     //什么时候执行配置服务,在程序执行完Build()之后,运行主机以前执行配置服务!
     //配置服务
     //ConfigureServices以依赖注入的方式将服务添加到服务(IOC)容器
     public void ConfigureServices(IServiceCollection services)
     {
          //Asp.NET Core内置的服务组件
          //添加对控制器和APi相关功能的支持,但是不支持视图和页面(Web Api的模板使用)
          services.AddControllers();
          //MVC的默认模板使用的
          services.AddControllersWithViews();
          //Web应用程序(Razor)
          services.AddRazorPages();
          //这个MVC他是3.0之前的版本,2.x版本使用的
          services.AddMvc(); 

          //以上的都是内置的,也可以添加第三方的服务,方法一致,这里将不过多描述了.

          //服务的生存周期
          //请求一个实例(是有生存周期,生存期)
          //三种:
          //  瞬死:A类控制器依赖B类服务,也给实例出来,如果B类是瞬死的,那梅一次都会生成一个新的实例
          //  作用域:每一次有客户请求时,的实例只会请求一次,在这次的请求中,后面的操作还需要这个B类实//例,他不会在创建了,把之前的拿过来直接用.
          //  单例:整个应用的生命周期，只要是向服务容器请求示例，第一次才会创建，之后都是使用这个。

          //注册服务的使用方式,可以采用构造函数注入的方式使用.
     }
     //配置管道
     public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
     {
          //如果想知道怎么添加中间件的,什么是终端中间件,怎么自定义中间件,中间件的顺序是怎么样的
          //可以加群,有学习文档.或者问群主:群号:782237863

          //判断是否是开发环境
          if (env.IsDevelopment())
          {
               //开发人员异常页面中间件,如果有异常,他会吧异常页面显示出来,且界面友好.
               app.UseDeveloperExceptionPage();
          }
          //终端路由中间件
          //识别路由，匹配路由和终结点
          app.UseRouting();
          //终结点中间件,配置路由和终结点之间的映射关系的
          //终结点:可以视为应用程序提供针对HTTP请求的处理器
          //MVC应用，终结点就对应着控制器中的某个方法
          app.UseEndpoints(endpoints =&gt;
          {
               //配置
               endpoints.MapGet(&quot;/&quot;, async context =&gt;
               {
                  await context.Response.WriteAsync(&quot;Hello World!&quot;);
               });
          });
      }
}</code></pre><p>人生要学会储蓄。你若耕耘，就储存了一次丰收；你若努力，就储存了一个希望；你若微笑，就储存了一份快乐。你能支取什么，取决于你储蓄了什么。没有储存友谊，就无法支取帮助；没有储存学识，就无法支取能力；没有储存汗水，就无法支取成长。想要取之不尽的幸福，要储蓄感恩和付出。晚安！</p>
]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>.NET Core</tag>
      </tags>
  </entry>
  <entry>
    <title>ICO容器-依赖注入</title>
    <url>/2020/05/27/Dependency/</url>
    <content><![CDATA[<hr>
<h1>IOC容器</h1>
<blockquote>
IOC是一种编程思想,不局限与任何一种语言,任何语言都可以实现这种思想，它的设计思想是想把创建对象，管理对象生命周期，程序集之间的解耦的工作交给第三方容器来处理。<br>
<a id="more"></a>
IOC作用:

<pre><code>1.注册类型,服务注册，将服务（类）以依赖注入的方式，添加到容器里,就是服务注册！
2.解析实例,比如我们注册了一个A类实例，这个时候我们不需要new了，直接从容器里面请求这个实例</code></pre></blockquote>
<h1>依赖注入</h1>
<blockquote>
我将会以讲故事的形式，给大家来介绍依赖注入和IOC容器。<br>
故事:假设我家的小宝出生了，这个时候饿了，肯定需要吃东西，对嘛，<br>

<pre><code>你会怎么办了？
1.叫外卖、去厨房找吃的、冰箱、冲牛奶  （主动）
2.叫妈妈、叫奶奶 （被动）</code></pre></blockquote>
<h3>解析:</h3>

<pre><code>这个时候饿了，肯定的情况下，需要食物对嘛？
1.方案1:我们主动获取食物，是有风险的。(比如并不知道哪些东西能吃的,不符合常理)(主动获取,我们称谓正转)
2.方案2:被动获取，食物是抽象的，父母给你的，决定安全，且适合你的(被动获取的,我们称谓反转,反转是食物的控制权)</code></pre><h3>说明:</h3>

<pre><code>食物是小宝所依赖的,也是抽象的,把所依赖的对象，反转了，就是控制反转(IOC)。
食物妈妈做好以后给你，或者喂给你，这个时候就是注入了。
妈妈就扮演者IOC容器的角色。</code></pre><p>没人在乎你怎样在深夜痛哭，也没人在乎你辗转反侧的要熬几个秋。外人只看结果，自己独撑过程。等我们都明白了这个道理，便不会再在人前矫情，四处诉说以求宽慰。晚安！</p>
]]></content>
      <categories>
        <category>ICO容器</category>
      </categories>
      <tags>
        <tag>ICO容器</tag>
      </tags>
  </entry>
</search>
