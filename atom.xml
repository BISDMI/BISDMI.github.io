<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SDMI</title>
  
  <subtitle>记录技术成长的点点滴滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.sdmi.top/"/>
  <updated>2020-07-13T07:33:04.059Z</updated>
  <id>https://www.sdmi.top/</id>
  
  <author>
    <name>李宝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OOA、OOD、OOP设计思想</title>
    <link href="https://www.sdmi.top/2020/07/13/OOADPesign/"/>
    <id>https://www.sdmi.top/2020/07/13/OOADPesign/</id>
    <published>2020-07-13T07:23:18.097Z</published>
    <updated>2020-07-13T07:33:04.059Z</updated>
    
    <content type="html"><![CDATA[<hr><h1>OOA面向对象的分析</h1><blockquote>OOA设计思想:面向对象分析<br>   【1】首先要明确你要做什么？<br>   【2】做成什么样子？也就是基本的需要分析，明确你要实现的功能。<br>   【3】当前市场同行软件有什么参考？比如我们这个，参考的是酷我音乐播放器(UI设计、核心功能的取舍)<br>   【4】细化自己的需求(进一步的对需求进行可行性分析)<br>   【5】准备开始设计项目<br></blockquote><a id="more"></a><h1>OOD面向对象设计</h1><blockquote>OOD设计思想:面向对象设计(UML设计)<br>   【1】明确项目类型？一般数据库应用系统？（模式单一）or 工具应用型系统<br>   【2】工具型应用软件有哪些特点:<br>            1.分析类<br>            2.设计类<br>            3.组合类<br></blockquote><h1>OOP面向对象设计</h1><blockquote>OOD设计思想:面向对象的编程/实现<br>【1】对象定义规格的求精过程     对于OOA所抽象出来的对象&类以及汇集的分析文档，OOD需要有一个根据设计要求整理和求精的过程，是指更能符合oop的需要。这个整理和求精过程主要有两个方面；一是根据面向对象的概念模型整理分析所确定的对象结构、属性、方法等内容，改正错误的内容，删去不必要和重复的内容等。而是进行分类整理，以便于下一步数据库设计和程序处理模块设计的必要。整理的方法主要是进行归类，对类、对象、属性、方法和结构、主题进行归类。<br>【2】数据模型和数据库设计数据模型的设计需要确定类与对象属性的内容,消息连接的方式.系统访问.数据模型的方法等.最后每个对象实例的数据都必须落实到面向对象的库结构模型中.<br>【3】优化:<br>    OOD的优化设计过程是从另一个角度对分析结果和处理业务过程的整理归纳,优化包括对象和结构的优化,抽象,继承.    对象和结构的模块化表示OOD提供了一种范式,这种范式支持对类和结构的模块化.这种模块符合一般模块化所要求的的所有特点,如信息隐蔽性好,内部聚合度强和模块之间耦合度弱等.    集成化使得单个构建有机的结合在一起,相互支持.</blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1&gt;OOA面向对象的分析&lt;/h1&gt;
&lt;blockquote&gt;
OOA设计思想:面向对象分析&lt;br&gt;
   【1】首先要明确你要做什么？&lt;br&gt;
   【2】做成什么样子？也就是基本的需要分析，明确你要实现的功能。&lt;br&gt;
   【3】当前市场同行软件有什么参考？比如我们这个，参考的是酷我音乐播放器(UI设计、核心功能的取舍)&lt;br&gt;
   【4】细化自己的需求(进一步的对需求进行可行性分析)&lt;br&gt;
   【5】准备开始设计项目&lt;br&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="OOA、OOD、OOP设计思想" scheme="https://www.sdmi.top/categories/OOA%E3%80%81OOD%E3%80%81OOP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"/>
    
    
      <category term="OOA、OOD、OOP设计思想" scheme="https://www.sdmi.top/tags/OOA%E3%80%81OOD%E3%80%81OOP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>面向对象六大原则</title>
    <link href="https://www.sdmi.top/2020/07/13/SixPrinciples/"/>
    <id>https://www.sdmi.top/2020/07/13/SixPrinciples/</id>
    <published>2020-07-13T06:56:22.960Z</published>
    <updated>2020-07-13T07:21:26.443Z</updated>
    
    <content type="html"><![CDATA[<hr><h1>面向对象的六大原则</h1><blockquote>面向对象的六大原则，就是让我们设计程序带入OOP思想，目标:让程序高扩展、高可维护、高性能。<br></blockquote><a id="more"></a><h1>单一职责(SRP)</h1><blockquote>概念:一个类只负责一个功能领域中相关的职责实现。也就是不能设计万能类。<br>PS:工具类型的软件需要涉及的类(UI、实体类、业务类)数控库应用系统(UI、实体类、业务类、数据    访问类、工具类)<br>UI:属于边界类：主要是用来收集用户操作数据，或者展示数据给用户，他不应该有具体的，               或者更多业务参与，更不能有其他的任务。<br>实例：三层架构设计理论基础，也是对象职责明确原则(单一职责)<br>好处：各个类各负其责！好处，当一个类的修改变化，不会影响到整个的程序。<br></blockquote><h1>里氏替换原则(LSP)</h1><blockquote>概念:子类必须能够替换掉它的父类类型，反之不行。<br>PS:里氏替换原则是实现开闭原则的重要方式之一<br>UI:提醒大家，以后变成尽量针对"基类"、"父类"、“编程”！换句话是，针对"接口"编程。<br>实例：人，可以被男人、女人替换的。父类 变量=子类对象 好处：子类可以替换父类，不仅原有的父类功能不受影响，而且还能扩展自己的新的行为。<br></blockquote><h1>迪米特法则(Lod)</h1><blockquote>概念:也叫最小化原则。当两个类之间直接通信的时候，会导致"高度"依赖（高耦合）          为了解决这个问题，我们应该尽量的避免这两个类直接“接触”(低耦合),可以通过一个第三者做转发。<br>PS:A->B->C<br>UI:迪米特法则根本思想就是让类之间解耦，实现是松耦合，达到更多的复用，一个类的修改不影响其他类。<br>实例：用户--->公司客服系统--->售后服务 如果你去找销售员，就是直接耦合！好处：封装思想，尽量降低成员的方权限，而不是全部public。一个类依赖的员一个类的实现越少越好！<br></blockquote><h1>开闭原则(OCP)</h1><blockquote>概念: 封闭修改，开放扩展。当需求变化的时候，我们尽量扩展对象，而不是修改原有对象。<br></blockquote><h1>依赖倒置原则(DIP)</h1><blockquote>概念: 抽象不应该依赖于细节，细节应该依赖于抽象。<br>PS:抽象不应该依赖于细节理解:生产主板的时候，是不用考虑那个厂家的"模块"。                 细节应该依赖于抽象的理解:生产各个模块的时候，必须遵循主板的接口！<br>UI:面向抽象编程就是说的DIP<br>实例：电脑主板，各个模块，都是按照主板接口来实现的，谁是抽象部分？主板各种插槽。                    细节:内存条，硬盘，独立显卡</blockquote><h1>接口隔离原则(ISP)</h1><blockquote>概念: 一个对象和另一个对象交互，所依赖的内容减少到最小，也就是说一个接口类设计必须严格遵循"单一职责"。                 不要设计万能接口，也不要设计过多接口，换句话说不能让接口泛滥。<br>PS:拆分多少合适？依靠大家的经验<br>实例：通过接口隔离，我们单独增加了接口类，方法也做了相应的扩展(实现自由组装，灵活方便)                  (非常类似于:数据库中的二范式或三范式!)</blockquote><h1>总结</h1><blockquote>1.单一职责:对象职责单一化2.开闭原则:对象修改最小化3.里氏替换原则:程序扩展具体方法4.迪米特法则:高内聚低耦合5.依赖倒置原则:不应该依赖于细节，依赖于抽象。6.接口隔离原则:接口设计要适中。</blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1&gt;面向对象的六大原则&lt;/h1&gt;
&lt;blockquote&gt;
面向对象的六大原则，就是让我们设计程序带入OOP思想，目标:让程序高扩展、高可维护、高性能。&lt;br&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="面向对象六大原则" scheme="https://www.sdmi.top/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    
    
      <category term="面向对象六大原则" scheme="https://www.sdmi.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>ICO容器-依赖注入</title>
    <link href="https://www.sdmi.top/2020/05/27/Dependency/"/>
    <id>https://www.sdmi.top/2020/05/27/Dependency/</id>
    <published>2020-05-27T02:54:38.421Z</published>
    <updated>2020-05-28T08:07:01.964Z</updated>
    
    <content type="html"><![CDATA[<hr><h1>IOC容器</h1><blockquote>IOC是一种编程思想,不局限与任何一种语言,任何语言都可以实现这种思想，它的设计思想是想把创建对象，管理对象生命周期，程序集之间的解耦的工作交给第三方容器来处理。<br><a id="more"></a>IOC作用:<pre><code>1.注册类型,服务注册，将服务（类）以依赖注入的方式，添加到容器里,就是服务注册！2.解析实例,比如我们注册了一个A类实例，这个时候我们不需要new了，直接从容器里面请求这个实例</code></pre></blockquote><h1>依赖注入</h1><blockquote>我将会以讲故事的形式，给大家来介绍依赖注入和IOC容器。<br>故事:假设我家的小宝出生了，这个时候饿了，肯定需要吃东西，对嘛，<br><pre><code>你会怎么办了？1.叫外卖、去厨房找吃的、冰箱、冲牛奶  （主动）2.叫妈妈、叫奶奶 （被动）</code></pre></blockquote><h3>解析:</h3><pre><code>这个时候饿了，肯定的情况下，需要食物对嘛？1.方案1:我们主动获取食物，是有风险的。(比如并不知道哪些东西能吃的,不符合常理)(主动获取,我们称谓正转)2.方案2:被动获取，食物是抽象的，父母给你的，决定安全，且适合你的(被动获取的,我们称谓反转,反转是食物的控制权)</code></pre><h3>说明:</h3><pre><code>食物是小宝所依赖的,也是抽象的,把所依赖的对象，反转了，就是控制反转(IOC)。食物妈妈做好以后给你，或者喂给你，这个时候就是注入了。妈妈就扮演者IOC容器的角色。</code></pre><p>没人在乎你怎样在深夜痛哭，也没人在乎你辗转反侧的要熬几个秋。外人只看结果，自己独撑过程。等我们都明白了这个道理，便不会再在人前矫情，四处诉说以求宽慰。晚安！</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1&gt;IOC容器&lt;/h1&gt;
&lt;blockquote&gt;
IOC是一种编程思想,不局限与任何一种语言,任何语言都可以实现这种思想，它的设计思想是想把创建对象，管理对象生命周期，程序集之间的解耦的工作交给第三方容器来处理。&lt;br&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="ICO容器" scheme="https://www.sdmi.top/categories/ICO%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="ICO容器" scheme="https://www.sdmi.top/tags/ICO%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>.NET Core</title>
    <link href="https://www.sdmi.top/2020/05/25/NetCore/"/>
    <id>https://www.sdmi.top/2020/05/25/NetCore/</id>
    <published>2020-05-25T07:16:56.290Z</published>
    <updated>2020-05-27T02:55:37.955Z</updated>
    
    <content type="html"><![CDATA[<hr><h1>初识.NET Core</h1><blockquote>.Net Core是一个开源的,是可以跨平台.跨架构.支持命令行.部署灵活.兼容性强的框架。<br>.Net Cree开源的,源码放在Github上面,属于社区开源，不仅仅是微软，社区也会提供支持。<br>.Net Core采用包化的管理方式，增加轻量性。<br></blockquote><a id="more"></a><h1>ASP.NET Core启动类</h1><blockquote>现在我们来简单介绍一下.Net Core3.1启动程序的两个类!<br>Program:被称谓主机配置和创建类!<br>Startup:被称谓Asp.Net Core应用的启动类,接下来,我会详细的描述每一组代码的意义和用途.<br></blockquote><pre><code>//主机配置和创建类public class Program{     //程序入口    public static void Main(string[] args)    {        //CreateHostBuilder是配置主机        //Build是创建主机 (.Net Core源码在这里执行了一组委托(创建主机))        //Run运行主机        CreateHostBuilder(args).Build().Run();    }    //这里为小白补充一下,什么是主机,用来干嘛的    //(主机:负责应用的启动类和生存期管理,配置服务器和请求处理管道,默认设置日志记录,依赖关系的注入和///配置,主机是一个封装了应用资源的对象,.Net Core里的一个类(Host))    //配置主机(.Net Core有两种主机,泛型,通用的主机)    public static IHostBuilder CreateHostBuilder(string[] args) =&gt;      //Host 主机静态类里面有一个CreateDefaultBuilder方法,是一个默认的创建主机构建器!      //ConfigureWebHostDefaults:Web主机(他是通用主机的扩展,他提供额外Web功能,支持Http,集成了//////Kestrel,内置了IIS集成)      Host.CreateDefaultBuilder(args)          .ConfigureWebHostDefaults(webBuilder =&gt;          {              //指定ASP.NET Core应用启动类(今天先写到这里,明天继续)              webBuilder.UseStartup&lt;Startup&gt;();          });}</code></pre><p>[加油,希望能为看的人,带来收获!]</p><pre><code>//ASP.NET Core Web应用的启动类public class Startup {     //什么时候执行配置服务,在程序执行完Build()之后,运行主机以前执行配置服务!     //配置服务     //ConfigureServices以依赖注入的方式将服务添加到服务(IOC)容器     public void ConfigureServices(IServiceCollection services)     {          //Asp.NET Core内置的服务组件          //添加对控制器和APi相关功能的支持,但是不支持视图和页面(Web Api的模板使用)          services.AddControllers();          //MVC的默认模板使用的          services.AddControllersWithViews();          //Web应用程序(Razor)          services.AddRazorPages();          //这个MVC他是3.0之前的版本,2.x版本使用的          services.AddMvc();           //以上的都是内置的,也可以添加第三方的服务,方法一致,这里将不过多描述了.          //服务的生存周期          //请求一个实例(是有生存周期,生存期)          //三种:          //  瞬死:A类控制器依赖B类服务,也给实例出来,如果B类是瞬死的,那梅一次都会生成一个新的实例          //  作用域:每一次有客户请求时,的实例只会请求一次,在这次的请求中,后面的操作还需要这个B类实//例,他不会在创建了,把之前的拿过来直接用.          //  单例:整个应用的生命周期，只要是向服务容器请求示例，第一次才会创建，之后都是使用这个。          //注册服务的使用方式,可以采用构造函数注入的方式使用.     }     //配置管道     public void Configure(IApplicationBuilder app, IWebHostEnvironment env)     {          //如果想知道怎么添加中间件的,什么是终端中间件,怎么自定义中间件,中间件的顺序是怎么样的          //可以加群,有学习文档.或者问群主:群号:782237863          //判断是否是开发环境          if (env.IsDevelopment())          {               //开发人员异常页面中间件,如果有异常,他会吧异常页面显示出来,且界面友好.               app.UseDeveloperExceptionPage();          }          //终端路由中间件          //识别路由，匹配路由和终结点          app.UseRouting();          //终结点中间件,配置路由和终结点之间的映射关系的          //终结点:可以视为应用程序提供针对HTTP请求的处理器          //MVC应用，终结点就对应着控制器中的某个方法          app.UseEndpoints(endpoints =&gt;          {               //配置               endpoints.MapGet(&quot;/&quot;, async context =&gt;               {                  await context.Response.WriteAsync(&quot;Hello World!&quot;);               });          });      }}</code></pre><p>人生要学会储蓄。你若耕耘，就储存了一次丰收；你若努力，就储存了一个希望；你若微笑，就储存了一份快乐。你能支取什么，取决于你储蓄了什么。没有储存友谊，就无法支取帮助；没有储存学识，就无法支取能力；没有储存汗水，就无法支取成长。想要取之不尽的幸福，要储蓄感恩和付出。晚安！</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1&gt;初识.NET Core&lt;/h1&gt;
&lt;blockquote&gt;
.Net Core是一个开源的,是可以跨平台.跨架构.支持命令行.部署灵活.兼容性强的框架。&lt;br&gt;
.Net Cree开源的,源码放在Github上面,属于社区开源，不仅仅是微软，社区也会提供支持。&lt;br&gt;
.Net Core采用包化的管理方式，增加轻量性。&lt;br&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term=".NET Core" scheme="https://www.sdmi.top/categories/NET-Core/"/>
    
    
      <category term=".NET Core" scheme="https://www.sdmi.top/tags/NET-Core/"/>
    
  </entry>
  
</feed>
